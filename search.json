[{"title":"Running ARM Linux in GEM5 FS mode","url":"/2021/10/03/gem5%20FS/","content":"本篇记录了在Ubuntu 18.04 + python 3.6.9 + gem5 20.1.0.5 full system mode运行ARM Linux的步骤以及遇到的坑。\n为了使用ARM Compute Library（开源）和Arm Performance Libraries（闭源），需要ARM Linux。\n本篇记录了在Ubuntu 18.04 + python 3.6.9 + gem5 20.1.0.5 full system mode运行ARM Linux的步骤以及遇到的坑。\n步骤\nPrerequisite\n sudo apt install build-essential git m4 scons zlib1g zlib1g-dev libprotobuf-dev \\protobuf-compiler libprotoc-dev libgoogle-perftools-dev \\python3-dev python3-six python-is-python3 libboost-all-dev \\pkg-config# 需要注意不同Ubuntu版本下的aarch64-gcc版本sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu binutils-aarch64-linux-gnu\nbuild gem5\ngit clone https://github.com/gem5/gem5.gitcd gem5/scons build/ARM/gem5.opt -j9# make bootloadermake -C system/arm/bootloader/armmake -C system/arm/bootloader/arm64# make device treesmake -C system/arm/dt# build m5ops librarycd util/m5scons build/aarch64/out/m5cd util/term; make\n下载pre-built ARM Linux kernel\nLatest Linux Kernel Image / Bootloader（最新版不知为何服务器上跑不了，这里换成了201901106版）\nLatest Linux Disk Images\n\n解压\nbzip2 -d aarch-system-20210904.tar.bz2 tar xvf aarch-system-20210904.tar\nbzip2 -d ubuntu-18.04-arm64-docker.img.bz2\n\n设置环境变量M5_PATH为aarch-system-20210904解压路径\necho &quot;export M5_PATH=\\&quot;~\\\\aarch-system-20210904\\&quot;&quot; &gt;&gt; ~/.bashrc; source ~/.bashrc\n\n扩容和添加内容（如Compiler, Library, Benchmark）到磁盘映像\narm-compiler-for-linux_21.0_Ubuntu-18.04_aarch64\nmkdir ~/mnt# 需要sudo，可以在自己虚拟机上整好再传到服务器上$GEM5_PATH/util/gem5img.py mount XXX.img ~/mntcp XXX mnt/root/XXX$GEM5_PATH/util/gem5img.py umount mnt\n\ndisk image 2G空间不够，用dd和gparted扩容\n# 扩容$ dd if=/dev/zero bs=1M count=10240 &gt;&gt; ./ubuntu-18.04-arm64-docker.img# 挂载$ sudo udisksctl loop-setup -f ./ubuntu-18.04-arm64-docker.imgMapped file linux-x86.img as /dev/loop0.# 用gparted把空闲空间加到image的sda1上$ sudo gparted /dev/loop0# 卸载$ sudo udisksctl loop-delete -b /dev/loop0\n启动\n$ ./build/ARM/gem5.opt ./configs/example/fs.py \\&gt;       --kernel $M5_PATH/binaries/vmlinux.arm64 \\&gt;       --disk-image $M5_PATH/disks/ubuntu-18.04-arm64-docker.img \\&gt;       --bootloader $M5_PATH/binaries/boot.arm64 \\&gt;       --param &quot;system.highest_el_is_64 = True&quot;\n\n或者\n./build/ARM/gem5.opt ./configs/example/arm/starter_fs.py \\\t--kernel /home/zhanglucheng/aarch-system-201901106/binaries/vmlinux.arm64 \\\t--disk-image /home/zhanglucheng/ubuntu-18.04-arm64-docker.img\n\n从输出信息中看终端端口号\nsystem.terminal: Listening for connections on port 3456\n\n则使用m5term连接3456即可使用终端\n./util/term/m5term 3456\n\n一般在gem5里启动aarch64 linux要5分钟左右\n\n设置checkpoint\n\nCheckpoints are essentially snapshops of a simulation. You would want to use a checkpoint when your simulation takes an extremely long time (which is almost always the case) so you can resume from that checkpoint at a later time with the DerivO3CPU.\n\n\nNormally create checkpoint in atomic memory mode\nRestore from checkpoint and change the system to be more detailed\n\n\n生成Checkpoint\n\n方法1（推荐）：用atmoic CPU启动后在虚拟机终端输入m5 checkpoint，即会生成m5out/cpt.TICKNUMBER\n\ngem5 also provides the m5 command-line tool which can be called from theconsole in a full-system simulation. e.g.\nm5 checkpoint\n\n​    m5 dump_stats  \n\n\n方法2：在C程序中使用m5ops\n  （需要提前cd $GEM5_PATH/util/m5; scons build/aarch64/out/m5）\n  #include &quot;gem5/m5ops.h&quot; // void m5_checkpoint(uint64_t ns_delay, uint64_t ns_period);...    m5_checkpoint(XXX, 0)...\n方法3：指令后加--take-checkpoints=&lt;M,N&gt;  take checkpoints at tick M and every N ticks thereafter       \n\n\n\n从Checkpoint恢复，换用detailed CPU\n 主要是--checkpoint-dir=m5out指定checkpoint的目录， -r 1指定第几个checkpoint，如果只有一个可以省略\n ./build/ARM/gem5.opt ./configs/example/fs.py \\    --kernel $M5_PATH/binaries/vmlinux.arm64 \\    --disk-image $M5_PATH/disks/ubuntu-18.04-arm64-docker.img \\    --bootloader $M5_PATH/binaries/boot.arm64 \\    --param &quot;system.highest_el_is_64 = True&quot; \\    --checkpoint-dir=m5out -r 1 \\    --restore-with-cpu=O3_ARM_v7a_3 --caches \\    --l1d_size=32kB --l1i_size=32kB \\    --l2cache --l2_size=2048kB\n\n 免去boot的过程直接进\n\n\n\n\n试错过程\nfs + 64 或 starter_fs + 32/64 都不行；\n用fs + 32位可跑，但最后会有kernel panic\n./build/ARM/gem5.opt ./configs/example/fs.py \\--kernel /home/zhanglucheng/aarch-system-20210904/binaries/vmlinux.arm \\--disk-image /home/zhanglucheng/ubuntu-18.04-arm64-docker.img\n\n[    0.444805] Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.[    0.444879] ---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---\nMail Archive类似状况解决办法：\n\n不能用GUI解压，要bzip2 -d aarch-system-201901106.tar.bz2 tar xvf aarch-system-201901106.tar\n\n--root /dev/vda1 加上似乎有别的问题\n\n\nUnrelated, could you use vmlinux.vexpress_gem5_v1_64 instead?\n\n\n\nthere are some incompatibilities between the prebuilt kernel andyour binutils\n\n换到自己的虚拟机ubuntu20.04 + gem5 21.0.1.0 也是\nwarn: Kernel panic in simulated kernel\n\n[    0.444806] Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.[    0.444880] ---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance. ]---\n\n\n尝试2019版另一个64位kernel，记得要修改M5_PATH\n./build/ARM/gem5.opt ./configs/example/fs.py --kernel /home/zhanglucheng/aarch-system-201901106/binaries/vmlinux.arm64 --disk-image /home/zhanglucheng/ubuntu-18.04-arm64-docker.img --bootloader /home/zhanglucheng/aarch-system-201901106/binaries/boot.arm64 --param &#x27;system.highest_el_is_64 = True&#x27;\n\n总结\nGUI解压工具Archive Manager就是辣鸡，应该用bzip2 -d aarch-system-201901106.tar.bz2 tar xvf aarch-system-201901106.tar\n如果用Archive Manager解压，运行时会卡在最开始\n\n用不同版本的pre-built kernel 需要修改M5_PATH export $M5_PATH=\\path\\to\\aarch-system-XXXX\n\nfs.py 需要参数 kernel disk-image bootloader 以及设置最高exception level = 64。不加bootloader会导致上述kernel panic\nstarter_fs.py 不用加bootloader和param，但需要提前make bootloader make -C $GEM5_PATH/system/arm/bootloader/arm64\n\n\n"},{"title":"gem5 notes (updating)","url":"/2021/10/03/gem5%20notes/","content":"参考 gem5: Learning gem5 和 Architectural Exploration with gem5\n\n模拟器在体系结构研究中的用途包括：降低评估硬件的成本、模拟手头没有的硬件、提升计算机性能数据的准确性、快速验证想法。现在对体系结构有了初步的了解，再重学一遍gem5，有了些更深入的理解。\nIntro\n gem5 is a modular discrete event driven computer system simulator platform.\n\n\ngem5 is designed for use in computer architecture research, but if you’re trying to research something new and novel it probably won’t be able to evaluate your idea out of the box. If it could, that probably means someone has already evaluated a similar idea and published about it.\n\n\ngem5 binary types: debug, opt, fast, prof and perf\nopt是优化最好的(-O3)且有debug symbol，fast最快最小\n其余参看gem5: Building gem5\n\n\n\nStartA simple config script\n注：为了在vscode中gem5的包有补全\n  echo &#x27;PYTHONPATH=$PYTHONPATH:$GEM5_PATH/build/ARM/python/m5&#x27; &gt;&gt; ~/.zshrc; source ~/.zshrc\ngem5中多数组件(CPUs, caches, memory controllers, buses, etc.)都是SimObjects ，由C++实现，接口暴露给python，用python来写配置脚本（设参数、说明连接方式）\n\nsimple.py \n  # import the m5 (gem5) library created when gem5 is built# 位于 $GEM5_PATH/build/ARM/python/m5import m5# import all of the SimObjectsfrom m5.objects import *# create the system we are going to simulate# System对象是所有其它对象的parent，有许多成员system = System()# Set the clock fequency of the system (and all of its children)system.clk_domain = SrcClockDomain()system.clk_domain.clock = &#x27;1GHz&#x27;system.clk_domain.voltage_domain = VoltageDomain()\t# 不关心功耗就默认# Set up the systemsystem.mem_mode = &#x27;timing&#x27;               # Use timing accessessystem.mem_ranges = [AddrRange(&#x27;512MB&#x27;)] # Create an address range# Create a simple CPU# TimingSimpleCPU每周期一条指令，除了访存交给memory systemsystem.cpu = TimingSimpleCPU()# Create a memory bus, a system crossbar, in this casesystem.membus = SystemXBar()# Hook the CPU ports up to the membus# BLL：对于membus slave := cpu_side_ports; master := mem_side_ports# 对于每个内存对象能有两种port (request and response)，需对应着连# 左右互换仍OK，但必须是request与response# 语法糖：允许port = array[port]system.cpu.icache_port = system.membus.cpu_side_portssystem.cpu.dcache_port = system.membus.cpu_side_ports# create the interrupt controller for the CPU and connect to the membussystem.cpu.createInterruptController()# For x86 only, make sure the interrupts are connected to the memory# Note: these are directly connected to the memory bus and are not cachedif m5.defines.buildEnv[&#x27;TARGET_ISA&#x27;] == &quot;x86&quot;:    system.cpu.interrupts[0].pio = system.membus.master    system.cpu.interrupts[0].int_master = system.membus.slave    system.cpu.interrupts[0].int_slave = system.membus.master# Create a DDR3 memory controller and connect it to the membussystem.mem_ctrl = MemCtrl()system.mem_ctrl.dram = DDR3_1600_8x8()system.mem_ctrl.dram.range = system.mem_ranges[0]system.mem_ctrl.port = system.membus.master# Connect the system up to the membussystem.system_port = system.membus.slave# get ISA for the binary to run.isa = str(m5.defines.buildEnv[&#x27;TARGET_ISA&#x27;]).lower()# Default to running &#x27;hello&#x27;, use the compiled ISA to find the binary# grab the specific path to the binarythispath = os.path.dirname(os.path.realpath(__file__))binary = os.path.join(thispath, &#x27;../../../&#x27;,                      &#x27;tests/test-progs/hello/bin/&#x27;, isa, &#x27;linux/hello&#x27;)system.workload = SEWorkload.init_compatible(binary)# Create a process for a simple &quot;Hello World&quot; applicationprocess = Process()# Set the command# cmd is a list which begins with the executable (like argv)process.cmd = [binary]# Set the cpu to use the process as its workload and create thread contextssystem.cpu.workload = processsystem.cpu.createThreads()# set up the root SimObject and start the simulation# 调用构造函数，不用先实例化再赋值root = Root(full_system = False, system = system)\t# instantiate all of the objects we&#x27;ve created abovem5.instantiate()print(&quot;Beginning simulation!&quot;)exit_event = m5.simulate()print(&#x27;Exiting @ tick %i because %s&#x27; % (m5.curTick(), exit_event.getCause()))\nSE模式专注于CPU和memory，不用实例化所有设备\n\nInO: MinorCPUOoO: DerivO3CPU(需要i$ d$分离)\n\n\nAdding Cache\ncache的simobject在src/mem/cache/Cache.py，python文件定义了可以设置的参数\ngem5有两种不同的cache模型系统 （由于历史原因，早晚合并）\nClassic: 来自m5，简化、固定的MOESI缓存一致性协议\nRuby：来自GEMS，对缓存一致性细致建模\n\n\n\n"},{"title":"性能分析","url":"/2021/09/30/profilers/","content":"参考 调试及性能分析 和 Tutorial - Perf Wiki\n\n由Amdahl’s Law，为了尽可能提升程序运行速度，需要分析程序的bottleneck，即耗时最长的部分（深度学习应用中通常为访存相关操作），再进行优化。使用性能分析工具可以找到程序中最耗时、最耗资源的部分。\n直接使用time()会被误导，因为程序运行时，执行时间会包含其他进程造成的等待。\ntime cmd\n\n\nreal - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）；\nUser - CPU 执行用户代码所花费的时间；\nSys - CPU 执行系统内核代码所花费的时间。\n\n性能分析工具 (profilers)python -m cProfile xxx.py\n\n逐行时间分析sudo apt install python3-line-profiler\n\n#!/usr/bin/env python3#coding=utf8import requestsfrom bs4 import BeautifulSoup# 这个装饰器会告诉行分析器 # 我们想要分析这个函数@profiledef get_urls():    response = requests.get(&#x27;https://missing.csail.mit.edu&#x27;)    s = BeautifulSoup(response.content, &#x27;lxml&#x27;)    urls = []    for url in s.find_all(&#x27;a&#x27;):        urls.append(url[&#x27;href&#x27;])if __name__ == &#x27;__main__&#x27;:    get_urls()\n\nkernprof -l -v foo.py\n\n内存分析sudo apt install python3-memory-profiler\n\n@profiledef my_func():    a = [1] * (10 ** 6)    b = [2] * (2 * 10 ** 7)    del b    return aif __name__ == &#x27;__main__&#x27;:    my_func()\n\n$ python3 -m memory_profiler bar.py       Filename: bar.pyLine #    Mem usage    Increment   Line Contents================================================     1   38.105 MiB   38.105 MiB   @profile     2                             def my_func():     3   45.770 MiB    7.664 MiB       a = [1] * (10 ** 6)     4  198.395 MiB  152.625 MiB       b = [2] * (2 * 10 ** 7)     5   45.848 MiB -152.547 MiB       del b     6   45.848 MiB    0.000 MiB       return a\n\n事件分析perf 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）\nsudo apt-get install linux-tools-5.11.0-34-genericperf list\n\n可视化 火焰图，调用图pycallgraph ，htop是top的改进版，iotop查看IO信息\ndf查看磁盘使用情况 du当前目录 -h友好显示\nfree查看空闲内存，lsof查看被进程打开的文件，ss监控网络包的收发情况\nPerfusage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]The most commonly used perf commands are:  annotate        Read perf.data (created by perf record) and display annotated code  archive         Create archive with object files with build-ids found in perf.data file  bench           General framework for benchmark suites  buildid-cache   Manage build-id cache.  buildid-list    List the buildids in a perf.data file  c2c             Shared Data C2C/HITM Analyzer.  config          Get and set variables in a configuration file.  data            Data file related processing  diff            Read perf.data files and display the differential profile  evlist          List the event names in a perf.data file  ftrace          simple wrapper for kernel&#x27;s ftrace functionality  inject          Filter to augment the events stream with additional information  kallsyms        Searches running kernel for symbols  kmem            Tool to trace/measure kernel memory properties  kvm             Tool to trace/measure kvm guest os  list            List all symbolic event types  lock            Analyze lock events  mem             Profile memory accesses  record          Run a command and record its profile into perf.data  report          Read perf.data (created by perf record) and display the profile  sched           Tool to trace/measure scheduler properties (latencies)  script          Read perf.data (created by perf record) and display trace output  stat            Run a command and gather performance counter statistics  test            Runs sanity tests.  timechart       Tool to visualize total system behavior during a workload  top             System profiling tool.  probe           Define new dynamic tracepoints  trace           strace inspired tool\n\n\n事件\n\n软事件：内核计数，如context-switches、minor-faults\nPMU硬件事件：来自处理器本身及其性能监视单元PMU，如周期数、失效指令、L1Cache miss，由CPU供应商提供文档\ntracepoint事件：由内核ftrace基础实现\n\n\nperf stat收集常见事件\n$ perf stat -B dd if=/dev/zero of=/dev/null count=10000001000000+0 records in1000000+0 records out512000000 bytes (512 MB, 488 MiB) copied, 0.460126 s, 1.1 GB/s Performance counter stats for &#x27;dd if=/dev/zero of=/dev/null count=1000000&#x27;:        459.490970      task-clock (msec)         #    0.992 CPUs utilized                         11      context-switches          #    0.024 K/sec                                  0      cpu-migrations            #    0.000 K/sec                                 62      page-faults               #    0.135 K/sec                    &lt;not supported&gt;      cycles                                                        &lt;not supported&gt;      instructions                                                  &lt;not supported&gt;      branches                                                      &lt;not supported&gt;      branch-misses                                                    0.463188434 seconds time elapsed\n\n-e task-clock指定事件，-e task-clock:u指定用户级别 -e task-clock:uk指定用户和内核\n\nperf record + perf report \n  比如运行一个alexnet实例：\n  $ perf record -r 10 ComputeLibrary/build/examples/graph_alexnet --target=Neon --data=$PATH_ASSETS --image=$PATH_ASSETS/go_kart.ppm --labels=$PATH_ASSETS/labels.txtComputeLibrary/build/examples/graph_alexnetThreads : 1Target : NeonData type : F32Data layout : NHWCTuner enabled? : falseCache enabled? : falseTuner mode : NormalTuner file :MLGO file :Fast math enabled? : falseData path : /root/alexnet_dataImage file : /root/alexnet_data/go_kart.ppmLabels file : /root/alexnet_data/labels.txt---------- Top 5 predictions ----------0.9736 - [id = 573], n03444034 go-kart0.0118 - [id = 518], n03127747 crash helmet0.0108 - [id = 751], n04037443 racer, race car, racing car0.0022 - [id = 817], n04285008 sports car, sport car0.0006 - [id = 670], n03791053 motor scooter, scooterTest passed[ perf record: Woken up 3 times to write data ][ perf record: Captured and wrote 0.711 MB perf.data (18409 samples) ]$ perf report# ========# os release : 4.15.0-156-generic# perf version : 4.15.18# arch : aarch64# nrcpus online : 2# nrcpus avail : 2# total memory : 4036928 kB# cmdline : /usr/lib/linux-tools-4.15.0-156/perf record ComputeLibrary/build/examples/graph_alexnet --target=Neon --data=/root/alexnet_data --image=/root/alexnet_data/go_kart.ppm --labels=/root/alexnet_data/labels.txt # event : name = cpu-clock, , type = 1, size = 112, &#123; sample_period, sample_freq &#125; = 4000, sample_type = IP|TID|TIME|PERIOD, disabled = 1, inherit = 1, mmap = 1, comm = 1, freq = 1, enable_on_exec = 1, task = 1, sample_id_all = 1, exclude_guest = 1, mmap2 = 1, comm_exec = 1# sibling cores   : 0-1# sibling threads : 0# sibling threads : 1# CPU 0: Core ID 0, Socket ID 60# CPU 1: Core ID 1, Socket ID 60# node0 meminfo  : total = 4036928 kB, free = 3293896 kB# node0 cpu list : 0-1# pmu mappings: armv8_pmuv3_0 = 6, software = 1, breakpoint = 5, tracepoint = 2# CPU cache info:#  L1 Data                 64K [0]#  L1 Instruction          64K [0]#  L1 Data                 64K [1]#  L1 Instruction          64K [1]#  L2 Unified             512K [0]#  L2 Unified             512K [1]#  L3 Unified           32768K [0-1]# missing features: TRACING_DATA CPUDESC CPUID BRANCH_STACK GROUP_DESC AUXTRACE STAT # ========### Total Lost Samples: 0## Samples: 18K of event &#x27;cpu-clock&#x27;# Event count (approx.): 4616500000## Overhead  Command        Shared Object            Symbol                                                                                                                                            # ........  .............  .......................  ..................................................................................................................................................#    15.01%  graph_alexnet  graph_alexnet            [.] arm_compute::utils::NPYLoader::fill_tensor&lt;arm_compute::ITensor&gt;    11.05%  graph_alexnet  libstdc++.so.6.0.25      [.] std::istream::read     8.65%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::(anonymous namespace)::transpose_32bit_elements     7.66%  graph_alexnet  libarm_compute.so        [.] arm_compute::TensorAllocator::data     6.89%  graph_alexnet  libstdc++.so.6.0.25      [.] std::istream::sentry::sentry     6.29%  graph_alexnet  libarm_compute.so        [.] arm_compute::TensorInfo::element_size     4.66%  graph_alexnet  libstdc++.so.6.0.25      [.] std::basic_filebuf&lt;char, std::char_traits&lt;char&gt; &gt;::xsgetn     3.18%  graph_alexnet  libarm_compute.so        [.] arm_compute::ITensorAllocator::info     3.12%  graph_alexnet  libarm_compute.so        [.] arm_compute::TensorInfo::offset_element_in_bytes     2.79%  graph_alexnet  libstdc++.so.6.0.25      [.] std::basic_streambuf&lt;char, std::char_traits&lt;char&gt; &gt;::xsgetn     2.43%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::CpuConvertFullyConnectedWeightsKernel::run_op     2.32%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083010     2.24%  graph_alexnet  [kernel.kallsyms]        [k] clear_page     1.80%  graph_alexnet  libarm_compute.so        [.] arm_gemm::Transform&lt;16u, 1u, true, (arm_gemm::VLType)0, float, float&gt;     1.32%  graph_alexnet  [kernel.kallsyms]        [k] __arch_copy_to_user     1.31%  graph_alexnet  libarm_compute.so        [.] arm_gemm::a64_hybrid_fp32_mla_6x16     1.26%  graph_alexnet  libarm_compute.so        [.] arm_compute::Tensor::info     1.16%  graph_alexnet  graph_alexnet            [.] std::istream::read@plt     1.16%  graph_alexnet  libarm_compute.so        [.] arm_compute::Tensor::buffer     1.16%  graph_alexnet  libc-2.27.so             [.] 0x000000000008300c     1.11%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083008     1.09%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083904     0.94%  graph_alexnet  [kernel.kallsyms]        [k] el0_da     0.92%  graph_alexnet  libarm_compute.so        [.] arm_compute::Memory::region@plt     0.79%  graph_alexnet  libc-2.27.so             [.] 0x0000000000082fa0     0.77%  graph_alexnet  libarm_compute.so        [.] arm_compute::Memory::region     0.76%  graph_alexnet  [kernel.kallsyms]        [k] _raw_spin_unlock_irqrestore     0.69%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083004     0.67%  graph_alexnet  libarm_compute.so        [.] arm_compute::ITensorAllocator::info@plt     0.48%  graph_alexnet  [kernel.kallsyms]        [k] free_unref_page_list     0.43%  graph_alexnet  libarm_compute.so        [.] arm_compute::TensorAllocator::data@plt     0.37%  graph_alexnet  libc-2.27.so             [.] 0x0000000000082f90     0.36%  graph_alexnet  [kernel.kallsyms]        [k] get_page_from_freelist     0.30%  graph_alexnet  [kernel.kallsyms]        [k] handle_mm_fault     0.25%  graph_alexnet  libarm_compute.so        [.] winograd::WeightTransform&lt;3, 3, 6, 6, float, float, (winograd::WinogradRoots)0&gt;::execute     0.23%  graph_alexnet  [kernel.kallsyms]        [k] mem_cgroup_commit_charge     0.23%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083000     0.22%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::(anonymous namespace)::run_permute&lt;unsigned int&gt;     0.22%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083900     0.21%  graph_alexnet  [kernel.kallsyms]        [k] try_charge     0.20%  graph_alexnet  [kernel.kallsyms]        [k] up_read     0.19%  graph_alexnet  [kernel.kallsyms]        [k] do_anonymous_page     0.15%  graph_alexnet  [kernel.kallsyms]        [k] unmap_page_range     0.14%  graph_alexnet  [kernel.kallsyms]        [k] release_pages     0.14%  graph_alexnet  libarm_compute.so        [.] arm_compute::NENormalizationLayerKernel::normalize_float&lt;float, 4u, 0u, false&gt;     0.12%  graph_alexnet  [kernel.kallsyms]        [k] __handle_mm_fault     0.12%  graph_alexnet  [kernel.kallsyms]        [k] __lru_cache_add     0.11%  graph_alexnet  [kernel.kallsyms]        [k] __lock_text_start     0.10%  graph_alexnet  [kernel.kallsyms]        [k] mem_cgroup_try_charge     0.10%  graph_alexnet  libarm_compute.so        [.] arm_gemm::a64_sgemm_asimd_8x12     0.08%  graph_alexnet  [kernel.kallsyms]        [k] __dec_node_page_state     0.08%  graph_alexnet  [kernel.kallsyms]        [k] __dec_node_state     0.08%  graph_alexnet  [kernel.kallsyms]        [k] down_read_trylock     0.08%  graph_alexnet  [kernel.kallsyms]        [k] vmacache_find     0.07%  graph_alexnet  [kernel.kallsyms]        [k] find_get_entry     0.07%  graph_alexnet  libarm_compute.so        [.] arm_gemm::Transform&lt;12u, 1u, true, (arm_gemm::VLType)0, float, float&gt;     0.06%  graph_alexnet  [kernel.kallsyms]        [k] get_mem_cgroup_from_mm     0.06%  graph_alexnet  [kernel.kallsyms]        [k] _cond_resched     0.06%  graph_alexnet  [kernel.kallsyms]        [k] generic_file_buffered_read     0.06%  graph_alexnet  [kernel.kallsyms]        [k] page_remove_rmap     0.05%  graph_alexnet  [kernel.kallsyms]        [k] do_page_fault     0.05%  graph_alexnet  [kernel.kallsyms]        [k] set_bit     0.05%  graph_alexnet  graph_alexnet            [.] arm_compute::graph_utils::CaffePreproccessor::preprocess_typed&lt;float&gt;     0.05%  graph_alexnet  [kernel.kallsyms]        [k] do_mem_abort     0.04%  graph_alexnet  [kernel.kallsyms]        [k] mark_page_accessed     0.04%  graph_alexnet  [kernel.kallsyms]        [k] uncharge_page     0.04%  graph_alexnet  [kernel.kallsyms]        [k] __alloc_pages_nodemask     0.04%  graph_alexnet  [kernel.kallsyms]        [k] __radix_tree_lookup     0.04%  graph_alexnet  [kernel.kallsyms]        [k] el0_svc_naked     0.04%  graph_alexnet  [kernel.kallsyms]        [k] free_unref_page_prepare.part.3     0.03%  graph_alexnet  [kernel.kallsyms]        [k] alloc_pages_vma     0.03%  graph_alexnet  [kernel.kallsyms]        [k] free_pages_and_swap_cache     0.03%  graph_alexnet  [kernel.kallsyms]        [k] page_counter_try_charge     0.03%  graph_alexnet  [kernel.kallsyms]        [k] workingset_activation     0.03%  graph_alexnet  [kernel.kallsyms]        [k] activate_page     0.03%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::CpuWeightsReshapeKernel::run_op     0.02%  graph_alexnet  [kernel.kallsyms]        [k] free_pgd_range     0.02%  graph_alexnet  [kernel.kallsyms]        [k] rcu_all_qs     0.02%  graph_alexnet  libarm_compute.so        [.] arm_compute::SubTensor::info     0.02%  graph_alexnet  libc-2.27.so             [.] malloc     0.02%  graph_alexnet  libpthread-2.27.so       [.] __libc_read     0.02%  graph_alexnet  libstdc++.so.6.0.25      [.] std::istream::get     0.02%  graph_alexnet  libstdc++.so.6.0.25      [.] std::istream::sentry::sentry@plt     0.02%  graph_alexnet  [kernel.kallsyms]        [k] __fsnotify_parent     0.02%  graph_alexnet  libarm_compute.so        [.] winograd::InputTransform&lt;6, 6, float, float, (winograd::WinogradRoots)0&gt;::transform_tile     0.02%  graph_alexnet  libc-2.27.so             [.] cfree     0.02%  graph_alexnet  libpthread-2.27.so       [.] __pthread_disable_asynccancel     0.01%  graph_alexnet  [kernel.kallsyms]        [k] __fget_light     0.01%  graph_alexnet  [kernel.kallsyms]        [k] __softirqentry_text_start     0.01%  graph_alexnet  [kernel.kallsyms]        [k] do_translation_fault     0.01%  graph_alexnet  [kernel.kallsyms]        [k] find_vma     0.01%  graph_alexnet  [kernel.kallsyms]        [k] fsnotify     0.01%  graph_alexnet  [kernel.kallsyms]        [k] get_task_policy.part.8     0.01%  graph_alexnet  [kernel.kallsyms]        [k] new_sync_read     0.01%  graph_alexnet  [kernel.kallsyms]        [k] pagecache_get_page     0.01%  graph_alexnet  [kernel.kallsyms]        [k] refill_stock     0.01%  graph_alexnet  graph_alexnet            [.] arm_compute::utils::IImageLoader::fill_planar_tensor&lt;arm_compute::ITensor&gt;     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000092d8     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::SubTensorInfo::element_size     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::CpuConcatenateWidthKernel::run_op     0.01%  graph_alexnet  libarm_compute.so        [.] arm_gemm::GemmHybridIndirect&lt;arm_gemm::cls_a64_hybrid_fp32_mla_6x16, float, float, arm_gemm::Nothing, false&gt;::execute     0.01%  graph_alexnet  libc-2.27.so             [.] 0x00000000000830f4     0.01%  graph_alexnet  libpthread-2.27.so       [.] __pthread_enable_asynccancel     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] std::basic_filebuf&lt;char, std::char_traits&lt;char&gt; &gt;::underflow     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] std::codecvt&lt;char, char, __mbstate_t&gt;::do_always_noconv     0.01%  graph_alexnet  [kernel.kallsyms]        [k] __clean_dcache_area_pou     0.01%  graph_alexnet  [kernel.kallsyms]        [k] __mod_node_page_state     0.01%  graph_alexnet  [kernel.kallsyms]        [k] __vma_rb_erase     0.01%  graph_alexnet  [kernel.kallsyms]        [k] __zone_watermark_ok     0.01%  graph_alexnet  [kernel.kallsyms]        [k] common_file_perm     0.01%  graph_alexnet  [kernel.kallsyms]        [k] copy_page_to_iter     0.01%  graph_alexnet  [kernel.kallsyms]        [k] copyout     0.01%  graph_alexnet  [kernel.kallsyms]        [k] current_time     0.01%  graph_alexnet  [kernel.kallsyms]        [k] down_write_killable     0.01%  graph_alexnet  [kernel.kallsyms]        [k] el1_ia     0.01%  graph_alexnet  [kernel.kallsyms]        [k] filemap_map_pages     0.01%  graph_alexnet  [kernel.kallsyms]        [k] free_unref_page     0.01%  graph_alexnet  [kernel.kallsyms]        [k] get_rps_cpu     0.01%  graph_alexnet  [kernel.kallsyms]        [k] get_vma_policy.part.12     0.01%  graph_alexnet  [kernel.kallsyms]        [k] inet_gro_receive     0.01%  graph_alexnet  [kernel.kallsyms]        [k] lock_page_memcg     0.01%  graph_alexnet  [kernel.kallsyms]        [k] lru_cache_add_active_or_unevictable     0.01%  graph_alexnet  [kernel.kallsyms]        [k] may_expand_vm     0.01%  graph_alexnet  [kernel.kallsyms]        [k] page_add_file_rmap     0.01%  graph_alexnet  [kernel.kallsyms]        [k] perf_output_put_handle     0.01%  graph_alexnet  [kernel.kallsyms]        [k] policy_node     0.01%  graph_alexnet  [kernel.kallsyms]        [k] radix_tree_lookup_slot     0.01%  graph_alexnet  [kernel.kallsyms]        [k] refcount_inc_not_zero     0.01%  graph_alexnet  [kernel.kallsyms]        [k] security_mmap_file     0.01%  graph_alexnet  [kernel.kallsyms]        [k] tlb_flush_mmu_tlbonly     0.01%  graph_alexnet  [kernel.kallsyms]        [k] tlb_next_batch.isra.4     0.01%  graph_alexnet  [kernel.kallsyms]        [k] unmapped_area_topdown     0.01%  graph_alexnet  graph_alexnet            [.] arm_compute::utils::operator&lt;&lt;     0.01%  graph_alexnet  ld-2.27.so               [.] 0x0000000000008818     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000088d8     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000089c8     0.01%  graph_alexnet  ld-2.27.so               [.] 0x0000000000008b7c     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000092e0     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000092e4     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000092f8     0.01%  graph_alexnet  ld-2.27.so               [.] 0x00000000000092fc     0.01%  graph_alexnet  ld-2.27.so               [.] 0x000000000000aad0     0.01%  graph_alexnet  ld-2.27.so               [.] 0x000000000000d164     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::NEConvolutionLayer::prepare     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::TensorInfo::clone     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::TensorInfo::operator=     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::(anonymous namespace)::mul_F32_F32_F32     0.01%  graph_alexnet  libarm_compute.so        [.] arm_compute::cpu::kernels::CpuReshapeKernel::run_op     0.01%  graph_alexnet  libarm_compute.so        [.] arm_conv::pooling::a64_fp32_nhwc_max_generic_depthfirst_impl     0.01%  graph_alexnet  libarm_compute.so        [.] arm_gemm::(anonymous namespace)::run_hybrid_kernel&lt;arm_gemm::Nothing, false&gt;::run&lt;arm_gemm::cls_a64_hybrid_fp32_mla_6x16, float, float, float&gt;     0.01%  graph_alexnet  libarm_compute.so        [.] winograd::OutputTransform&lt;3, 3, 6, 6, float, float, (winograd::WinogradRoots)0&gt;::transform_tile     0.01%  graph_alexnet  libarm_compute_graph.so  [.] arm_compute::graph::backends::detail::get_backing_tensor&lt;arm_compute::graph::backends::NETargetInfo&gt;     0.01%  graph_alexnet  libc-2.27.so             [.] __stpncpy     0.01%  graph_alexnet  libc-2.27.so             [.] __strxfrm_l     0.01%  graph_alexnet  libc-2.27.so             [.] fclose     0.01%  graph_alexnet  libc-2.27.so             [.] strlen     0.01%  graph_alexnet  libc-2.27.so             [.] 0x00000000000440c8     0.01%  graph_alexnet  libc-2.27.so             [.] 0x0000000000072b08     0.01%  graph_alexnet  libc-2.27.so             [.] 0x0000000000073fe8     0.01%  graph_alexnet  libc-2.27.so             [.] 0x00000000000755e0     0.01%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083028     0.01%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083084     0.01%  graph_alexnet  libc-2.27.so             [.] 0x0000000000083088     0.01%  graph_alexnet  libc-2.27.so             [.] 0x00000000000830d8     0.01%  graph_alexnet  libc-2.27.so             [.] 0x00000000000830dc     0.01%  graph_alexnet  libc-2.27.so             [.] 0x00000000000ad1a0     0.01%  graph_alexnet  libgcc_s.so.1            [.] __trunctfdf2     0.01%  graph_alexnet  libm-2.27.so             [.] powf     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] __cxxabiv1::__vmi_class_type_info::__do_dyncast     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] __floatsitf@plt     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] __trunctfdf2@plt     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] operator delete@plt     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_append     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] std::__detail::_List_node_base::_M_transfer     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] std::getline&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] std::use_facet&lt;std::ctype&lt;char&gt; &gt;     0.01%  graph_alexnet  libstdc++.so.6.0.25      [.] strcmp@plt\n\n  可以看到主要overhead都在于访存相关操作上。\n\nperf annotate指令级分析，编译程序时加 -ggdb可以逐行看\n\nperf top现场分析\n\nperf bench基准测试\n\nsched调度器基准测试测量：多个任务之间的pipe(2)和socketpair(2)操作。允许测量线程与进程上下文切换的性能。\nmem:内存访问基准测试\nnuma: numa调度和MM基准测试\nfutex: futex压力基准测试：处理futex内核实现的细粒度方面。它对于内核黑客非常有用。它目前支持唤醒和重新排队/等待操作，并强调私有和共享futexes的哈希方案。\n\n\n\ngprof and gpeftoolsgprof: GNU profiler，对应gem5.prof\ngpeftools: google的性能分析工具，对应gem5.perf，哪天学习一下\n"}]